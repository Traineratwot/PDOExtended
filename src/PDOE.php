<?php

	namespace Traineratwot\PDOExtended;

	use PDO;
	use PDOException;
	use Traineratwot\Cache\Cache;
	use Traineratwot\PDOExtended\drivers\SQLite;
	use Traineratwot\PDOExtended\exceptions\DsnException;
	use Traineratwot\PDOExtended\exceptions\PDOEException;
	use Traineratwot\PDOExtended\interfaces\DriverInterface;
	use Traineratwot\PDOExtended\interfaces\DsnInterface;
	use Traineratwot\PDOExtended\statement\PDOEPoolStatement;
	use Traineratwot\PDOExtended\statement\PDOEStatement;


	/**
	 * @method getScheme()
	 */
	class PDOE extends PDO implements DriverInterface
	{
		/**
		 * PostgreSQL
		 * <img src="https://wiki.postgresql.org/images/3/30/PostgreSQL_logo.3colors.120x120.png" width="50" height="50" />
		 */
		public const DRIVER_PostgreSQL = 'pgsql';
		/**
		 * SQLite
		 * <img src="https://cdn.icon-icons.com/icons2/2699/PNG/512/sqlite_logo_icon_169724.png" width="50" height="50" />
		 */
		public const DRIVER_SQLite = 'sqlite';
		/**
		 * PostgreSQL
		 * <img src="https://img-blog.csdnimg.cn/20200828185219514.jpg?x-oss-process=image/resize,m_fixed,h_64,w_64" width="50" height="50" />
		 */
		public const DRIVER_MySQL    = 'mysql';
		public const CHARSET_utf8    = 'utf8';
		public const CHARSET_utf8mb4 = 'utf8mb4';
		public const DRIVER_classes
									 = [
				self::DRIVER_PostgreSQL => '',
				self::DRIVER_SQLite     => SQLite::class,
				self::DRIVER_MySQL      => '',
			];
		/**
		 * @var array|false
		 */
		private $query_count = 0;

		/**
		 * @var dsn
		 */
		public $dsn;
		/**
		 * @var DriverInterface
		 */
		private DriverInterface $driver;

		/**
		 * @inheritDoc
		 * @param Dsn   $dsn
		 * @param array $driverOptions
		 * @throws DsnException
		 * @throws PDOEException
		 */
		public function __construct(DsnInterface $dsn, $driverOptions = [])
		{
			$this->dsn = $dsn;
			try {
				parent::__construct($dsn->get(), $dsn->getUsername(), $dsn->getPassword(), $driverOptions);
			} catch (PDOException $e) {
				throw new DsnException($dsn->get(), $e->getCode(), $e);
			}
			$this->setAttribute(PDO::ATTR_STATEMENT_CLASS, [PDOEStatement::class, [$this]]);
			$driverClass = self::DRIVER_classes[$this->dsn->getDriver()];
			if (!class_exists($driverClass)) {
				throw new PDOEException('Invalid driver class: ' . $driverClass);
			}
			$this->driver = new $driverClass($this);
		}

		/**
		 * @return int
		 */
		public function queryCount()
		{
			return $this->query_count;
		}

		/**
		 * @inheritDoc
		 */
		public function exec($statement)
		{
			$this->queryCountIncrement();
			return parent::exec($statement); // TODO: Change the autogenerated stub
		}

		/**
		 * @return void
		 */
		public function queryCountIncrement()
		: void
		{
			$this->query_count++;
		}

		/**
		 * @throws PDOEException
		 */
		public function __call(string $name, array $arguments = [])
		{
			if (method_exists($this->driver, $name)) {
				return $this->driver->{$name}(...$arguments);
			}
			throw new PDOEException("Method $name is not exists");
		}

		/**
		 * @inheritDoc
		 */
		public function query($statement, $mode = self::ATTR_DEFAULT_FETCH_MODE, $arg3 = NULL, array $ctorargs = [])
		{
			$arg = func_get_args();
			$this->queryCountIncrement();
			return parent::query(...$arg);
		}

		public function prepareQuery($statement, $values = [], $mode = self::ATTR_DEFAULT_FETCH_MODE, $arg3 = NULL, array $ctorargs = [])
		{
			$statement = Helpers::prepare($statement, $values, $this);
			$arg       = func_get_args();
			$arg       = array_slice($arg, 2);
			return $this->query($statement, ...$arg);
		}

		/**
		 * @param string $statement SQL request
		 * @param array  $driver_options
		 * @return bool|PDOEPoolStatement
		 */
		public function poolPrepare(string $statement, array $driver_options = [])
		{
			$this->setAttribute(PDO::ATTR_STATEMENT_CLASS, [PDOEPoolStatement::class, [$this]]);
			return parent::prepare($statement, $driver_options);
		}

		/**
		 * @inheritDoc
		 */
		public function prepare($query, $options = NULL)
		{
			$this->setAttribute(PDO::ATTR_STATEMENT_CLASS, [PDOEStatement::class, [$this]]);
			return parent::prepare($query, $options);
		}

		/**
		 * @param string $name
		 * @return array|false|int|null
		 */
		public function __get(string $name)
		{
			switch ($name) {
				case 'query_count':
				case 'queryCount':
					return $this->queryCount();
			}
			return NULL;
		}

		/**
		 * @param string $name
		 * @param        $value
		 * @return false
		 */
		public function __set(string $name, $value)
		{
			return FALSE;
		}

		/**
		 * @param string $name
		 * @return bool
		 */
		public function __isset(string $name)
		{
			return $name === 'query_count';
		}

		/**
		 * @return array|false
		 */
		public function getQueryCount()
		{
			return $this->query_count;
		}


		/**
		 * return list all tables in database
		 * @return array
		 */
		public function getTablesList()
		: array
		{
			return $this->driver->getTablesList();
		}

		public function tableExists(string $table)
		: string
		{
			return $this->driver->tableExists($table);
		}

		/**
		 * @param DsnInterface $dsn
		 * @param array        $driverOptions
		 * @param string|null  $var return global variable name
		 * @return self
		 * @throws DsnException
		 * @throws PDOEException
		 */
		public static function init(DsnInterface $dsn, array $driverOptions = [], ?string &$var = '')
		: PDOE
		{
			$key = Cache::getKey([$dsn->get(), $driverOptions]);
			$var = 'PDOE_' . $key;
			global $$var;
			if (!isset($$var) || is_null($$var)) {
				$$var = new self($dsn, $driverOptions);
			}
			return $$var;
		}

		/**
		 * (PHP 5 &gt;= 5.1.0, PHP 7, PECL pdo &gt;= 0.2.1)<br/>
		 * Quotes a string for use in a query.
		 * @link https://php.net/manual/en/pdo.quote.php
		 * @param mixed $string <p>
		 *                      The string to be quoted.
		 *                      </p>
		 * @param ?int  $type   [optional] <p>
		 *                      Provides a data type hint for drivers that have alternate quoting styles.
		 *                      </p>
		 * @return string|false a quoted string that is theoretically safe to pass into an
		 *                      SQL statement. Returns <b>FALSE</b> if the driver does not support quoting in
		 *                      this way.
		 */
		public function quote($string, $type = NULL)
		{
			if (is_null($type)) {
				if (is_numeric($string)) {
					$type = self::PARAM_INT;
				} else {
					$type = self::PARAM_STR;
				}
			}
			return parent::quote($string, $type);
		}
	}

